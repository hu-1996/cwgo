layouts:
  - path: main.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator.

      package main

      import (
        "context"
      	"time"

        "{{.GoModule}}/{{$.Module}}/biz/router"
        "{{.GoModule}}/{{$.Module}}/conf"
      
        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery"
        "github.com/cloudwego/hertz/pkg/app/server"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/hertz-contrib/cors"
        "github.com/hertz-contrib/gzip"
        "github.com/hertz-contrib/logger/accesslog"
        "github.com/hertz-contrib/pprof"
      )

      func main() {
        // init dal
        // dal.Init()
      	address := conf.GetConf().Hertz.Address
      	h := server.New(server.WithHostPorts(address))

        registerMiddleware(h)

      	router.GeneratedRegister(h)

      	h.Spin()
      }

      func registerMiddleware(h *server.Hertz) {
      	// log
      	hlog.SetLevel(conf.LogLevel())

      	// pprof
      	if conf.GetConf().Hertz.EnablePprof {
      		pprof.Register(h)
      	}

      	// gzip
      	if conf.GetConf().Hertz.EnableGzip {
      		h.Use(gzip.Gzip(gzip.DefaultCompression))
      	}

        // access log
        if conf.GetConf().Hertz.EnableAccessLog {
          h.Use(accesslog.New())
        }

        // recovery
        h.Use(recovery.Recovery())

         // cores
        h.Use(cors.Default())
      }

  - path: go.mod
    delims:
      - "{{"
      - "}}"
    body: |-
      module {{.GoModule}}
      {{- if .UseApacheThrift}}
      replace github.com/apache/thrift => github.com/apache/thrift v0.13.0
      {{- end}}

  - path: biz/router/register.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator. DO NOT EDIT.

      package router

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      )

      // GeneratedRegister registers routers generated by IDL.
      func GeneratedRegister(r *server.Hertz){
      	//INSERT_POINT: DO NOT DELETE THIS LINE!
      }

  - path: conf/conf.go
    delims:
      - ""
      - ""
    body: |-
      package conf

      import (
      	"os"
        "path/filepath"
        "sync"

      	"github.com/cloudwego/hertz/pkg/common/hlog"
      	"github.com/kr/pretty"
      	"gopkg.in/validator.v2"
      	"gopkg.in/yaml.v3"
      )

      var (
      	conf *Config
      	once sync.Once
      )

      type Config struct {
      	Env string

      	Hertz Hertz `yaml:"hertz"`
        MySQL MySQL `yaml:"mysql"`
        Redis Redis `yaml:"redis"`
      }

      type MySQL struct {
      	DSN string `yaml:"dsn"`
      }


      type Redis struct {
      	Address  string `yaml:"address"`
      	Password string `yaml:"password"`
        Username string `yaml:"username"`
        DB       int    `yaml:"db"`
      }

      type Hertz struct {
      	Address       string `yaml:"address"`
      	EnablePprof   bool   `yaml:"enable_pprof"`
      	EnableGzip    bool   `yaml:"enable_gzip"`
        EnableAccessLog bool   `yaml:"enable_access_log"`
      	LogLevel      string `yaml:"log_level"`
      }

      // GetConf gets configuration instance
      func GetConf() *Config {
      	once.Do(initConf)
      	return conf
      }

      func initConf() {
      	prefix := "{{$.Module}}/conf"
      	confFileRelPath := filepath.Join(prefix, filepath.Join(GetEnv(), "conf.yaml"))
      	content, err := os.ReadFile(confFileRelPath)
      	if err != nil {
      		panic(err)
      	}

      	conf = new(Config)
      	err = yaml.Unmarshal(content, conf)
      	if err != nil {
      		hlog.Error("parse yaml error - %v", err)
      		panic(err)
      	}
      	if err := validator.Validate(conf); err != nil {
      		hlog.Error("validate config error - %v", err)
      		panic(err)
      	}

      	conf.Env = GetEnv()

      	pretty.Printf("%+v\n", conf)
      }

      func GetEnv() string {
      	e := os.Getenv("GO_ENV")
      	if len(e) == 0 {
      		return "dev"
      	}
      	return e
      }

      func LogLevel() hlog.Level {
      	level := GetConf().Hertz.LogLevel
      	switch level {
      	case "trace":
      		return hlog.LevelTrace
      	case "debug":
      		return hlog.LevelDebug
      	case "info":
      		return hlog.LevelInfo
      	case "notice":
      		return hlog.LevelNotice
      	case "warn":
      		return hlog.LevelWarn
      	case "error":
      		return hlog.LevelError
      	case "fatal":
      		return hlog.LevelFatal
      	default:
      		return hlog.LevelInfo
      	}
      }

  - path: conf/dev/conf.yaml
    delims:
      - ""
      - ""
    body: |-
      hertz:
        service: "{{.ServiceName}}"
        address: ":8080"
        enable_pprof: true
        enable_gzip: true
        enable_access_log: true
        log_level: debug

      mysql:
        dsn: "gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8mb4&parseTime=True&loc=Local"

      redis:
        address: "127.0.0.1:6379"
        username: ""
        password: ""
        db: 0

  - path: conf/online/conf.yaml
    delims:
      - ""
      - ""
    body: |-
      hertz:
        service: "{{.ServiceName}}"
        address: ":8080"
        enable_pprof: false
        enable_gzip: true
        enable_access_log: false
        log_level: info

      mysql:
        dsn: "gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8mb4&parseTime=True&loc=Local"

      redis:
        address: "127.0.0.1:6379"
        username: ""
        password: ""
        db: 0

  - path: conf/test/conf.yaml
    delims:
      - ""
      - ""
    body: |-
      hertz:
        service: "{{.ServiceName}}"
        address: ":8080"
        enable_pprof: true
        enable_gzip: true
        enable_access_log: true
        log_level: debug

      mysql:
        dsn: "gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8mb4&parseTime=True&loc=Local"

      redis:
        address: "127.0.0.1:6379"
        username: ""
        password: ""
        db: 0

  - path: biz/dal/init.go
    delims:
      - ""
      - ""
    body: |-
      package dal

      import (
      	"{{.GoModule}}/{{$.Module}}/biz/dal/mysql"
      	"{{.GoModule}}/{{$.Module}}/biz/dal/redis"
      )

      func Init() {
      	redis.Init()
      	mysql.Init()
      }

  - path: biz/dal/mysql/init.go
    delims:
      - ""
      - ""
    body: |-
      package mysql

      import (
      	"{{.GoModule}}/{{$.Module}}/conf"
      	"gorm.io/driver/mysql"
      	"gorm.io/gorm"
      )

      var (
      	DB  *gorm.DB
      	err error
      )

      func Init() {
      	DB, err = gorm.Open(mysql.Open(conf.GetConf().MySQL.DSN),
      		&gorm.Config{
      			PrepareStmt:            true,
      			SkipDefaultTransaction: true,
      		},
      	)
      	if err != nil {
      		panic(err)
      	}
      }

  - path: biz/dal/redis/init.go
    delims:
      - ""
      - ""
    body: |-
      package redis

      import (
      	"context"

      	"github.com/redis/go-redis/v9"
      	"{{.GoModule}}/{{$.Module}}/conf"
      )

      var RedisClient *redis.Client

      func Init() {
      	RedisClient = redis.NewClient(&redis.Options{
      		Addr:     conf.GetConf().Redis.Address,
      		Username: conf.GetConf().Redis.Username,
      		Password: conf.GetConf().Redis.Password,
      		DB:       conf.GetConf().Redis.DB,
      	})
      	if err := RedisClient.Ping(context.Background()).Err(); err != nil {
      		panic(err)
      	}
      }

  - path: docker-compose.yaml
    delims:
      - ""
      - ""
    body: |-
      version: '3'
      services:
        mysql:
          image: 'mysql:latest'
          ports:
            - 3306:3306
          environment:
            - MYSQL_DATABASE=gorm
            - MYSQL_USER=gorm
            - MYSQL_PASSWORD=gorm
            - MYSQL_RANDOM_ROOT_PASSWORD="yes"
        redis:
          image: 'redis:latest'
          ports:
            - 6379:6379

  - path: readme.md
    delims:
      - ""
      - ""
    body: |-
      # *** Project

      ## 开发

      ### 安装代码生成工具

      ```shell
      GOPROXY=https://goproxy.cn/,direct go install github.com/hu-1996/cwgo@latest
      ```

      ### 通过idl生成代码
      ```shell
      cwgo server --type HTTP --server_name {{.ServiceName}}  --idl idl/xxx.proto -module {{.ServiceName}} --out_dir app --template standard_v2
      ```

      生成代码结构如下：

      .
      ├── apis
      │   ├── api
      │   │   └── api.pb.go
      │   └── xxx
      │       └── xxx.pb.go
      ├── app
      │   ├── biz
      │   │   ├── dal
      │   │   │   ├── init.go
      │   │   │   ├── mysql
      │   │   │   │   └── init.go
      │   │   │   └── redis
      │   │   │       └── init.go
      │   │   ├── handler
      │   │   │   └── xxx
      │   │   │       ├── xxx_service_test.go
      │   │   │       └── xxx_service.go
      │   │   ├── router
      │   │   │   ├── xxx
      │   │   │   │   ├── middleware.go
      │   │   │   │   └── xxx.go
      │   │   │   └── register.go
      │   │   └── service
      │   │       └── xxx
      │   │           └── get_xxx.go
      │   ├── conf
      │   │   ├── conf.go
      │   │   ├── dev
      │   │   │   └── conf.yaml
      │   │   ├── online
      │   │   │   └── conf.yaml
      │   │   └── test
      │   │       └── conf.yaml
      │   └── main.go
      ├── build.sh
      ├── docker-compose.yaml
      ├── errno
      │   └── errno.go
      ├── go.mod
      ├── go.sum
      ├── idl
      │   ├── api.proto
      │   └── model_file.proto
      ├── readme_developer.md
      ├── readme.md
      ├── script
      │   └── bootstrap.sh
      └── utils
          └── resp.go

      23 directories, 27 files
      ```

  - path: .gitignore
    delims:
      - ""
      - ""
    body: |-
      *.o
      *.a
      *.so
      _obj
      _test
      *.[568vq]
      [568vq].out
      *.cgo1.go
      *.cgo2.c
      _cgo_defun.c
      _cgo_gotypes.go
      _cgo_export.*
      _testmain.go
      *.exe
      *.exe~
      *.test
      *.prof
      *.rar
      *.zip
      *.gz
      *.psd
      *.bmd
      *.cfg
      *.pptx
      *.log
      *nohup.out
      *settings.pyc
      *.sublime-project
      *.sublime-workspace
      !.gitkeep
      .DS_Store
      /.idea
      /.vscode
      /output
      *.local.yml

  - path: biz/utils/resp.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package utils

      import (
        "errors"
      
        "{{.GoModule}}/errno"
    
        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
      )
      
      type Response struct {
        // 数据集
        RequestId string      `json:"requestId,omitempty"`
        Code      int32       `json:"code,omitempty"`
        Message   string      `json:"message,omitempty"`
        Status    bool        `json:"status,omitempty"`
        Data      interface{} `json:"data"`
        Error     string      `json:"error,omitempty"`
      }
    
      // BuildBaseResp convert error and build BaseResp
      func BuildBaseResp(c *app.RequestContext, data interface{}, err error) {
        if err == nil {
          baseResp(c, data, errno.Success)
          return
        }
    
        e := errno.ErrNo{}
        if errors.As(err, &e) {
          baseResp(c, data, e)
          return
        }
    
        s := errno.ServiceErr.WithMessage(err.Error())
        baseResp(c, nil, s)
        return
      }
    
      // baseResp build BaseResp from error
      func baseResp(c *app.RequestContext, data interface{}, err errno.ErrNo) {
          message := err.ErrMsg
          if lang := c.GetHeader("lang"); string(lang) == "zh" {
          message = err.ErrCnMsg
        }
    
        c.JSON(err.HttpCode, &Response{
          Code:    err.ErrCode,
          Message: message,
          Status:  err.ErrCode == errno.OKCode,
          Data:    data,
        })
      }
    
      // BuildBadResp convert error and build BadResp
      func BuildBadResp(c *app.RequestContext, data interface{}, err error) {
        if e, ok := err.(errno.ErrNo); ok {
          message := e.ErrMsg
          if lang := c.GetHeader("lang"); string(lang) == "zh" {
          message = e.ErrCnMsg
        }
    
        c.JSON(e.HttpCode, &Response{
          Code:    e.ErrCode,
          Message: message,
          Status:  e.ErrCode == errno.OKCode,
          Data:    data,
        })
        return
        }
    
        s := errno.ServiceErr.WithMessage(err.Error())
        badResp(c, consts.StatusInternalServerError, nil, s)
        return
      }
    
      // badResp build BadResp from error
      func badResp(c *app.RequestContext, code int, data interface{}, err errno.ErrNo) {
        message := err.ErrMsg
        if lang := c.GetHeader("lang"); string(lang) == "zh" {
        message = err.ErrCnMsg
      }
    
      c.JSON(code, &Response{
        Code:    err.ErrCode,
        Message: message,
        Status:  err.ErrCode == errno.OKCode,
        Data:    data,
      })
      }
    
      func BuildResp(c *app.RequestContext, code int, data interface{}) {
        c.JSON(code, data)
      }

  - path: biz/errno/errno.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package errno

      import (
        "errors"
        "fmt"
      
        "github.com/cloudwego/hertz/pkg/protocol/consts"
      )
      
      const (
        OKCode         = 20000
        ServiceErrCode = 60000
      )
      
      const (
        OkMsg                  = "Ok"
      )
      
      type ErrNo struct {
        ErrCode  int32
        ErrMsg   string
        ErrCnMsg string
        HttpCode int
      }

      func (e ErrNo) Error() string {
        return e.ErrMsg
      }
  
      func NewErrNo(code int32, msg string, cnMsg string, httpCode int) ErrNo {
        return ErrNo{code, msg, cnMsg, httpCode}
      }
  
      func (e ErrNo) WithMessage(msg string) ErrNo {
        e.ErrMsg = msg
        e.ErrCnMsg = msg
        return e
      }
  
      func (e ErrNo) WithMessageAppend(msg string, cnMsg string) ErrNo {
        e.ErrMsg = fmt.Sprintf("%s %s", e.ErrMsg, msg)
        e.ErrCnMsg = fmt.Sprintf("%s %s", e.ErrCnMsg, cnMsg)
        return e
      }
  
      func (e ErrNo) GetCnMessage() string {
        return e.ErrCnMsg
      }
  
      var (
        // 200
        Success    = NewErrNo(OKCode, OkMsg, "成功", consts.StatusOK)
        ServiceErr = NewErrNo(ServiceErrCode, "Request processing has failed due to some unknown error.", "由于未知错误，请求处理失败", consts.StatusInternalServerError)
      )
        
      // ConvertErr convert error to Errno
      func ConvertErr(err error) ErrNo {
        Err := ErrNo{}
        if errors.As(err, &Err) {
          return Err
        }
  
        s := ServiceErr
        s.ErrMsg = err.Error()
        return s
      }

  - path: build.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      if [ $# -ne 2 ]; then
        echo "Error: 需要两个参数 - path 和 service_name"
        echo "用法: $0 <path> <service_name>"
        exit 1
      fi
      path=$1
      service_name=$2
      RUN_NAME={{.ServiceName}}/${service_name}
      mkdir -p output/bin/{{.ServiceName}} output/{{.ServiceName}}/conf
      cp script/bootstrap.sh output 2>/dev/null
      chmod +x output/bootstrap.sh
      cp -r conf/* output/conf
      go build -o output/bin/${RUN_NAME} ${path}/main.go

  - path: script/bootstrap.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      if [ $# -ne 1 ]; then
        echo "错误: 需要一个参数 - service_name"
        echo "用法: $0 <service_name>"
        exit 1
      fi
      service_name=$1
      CURDIR=$(cd $(dirname $0); pwd)
      BinaryName={{.ServiceName}}/${service_name}
      echo "$CURDIR/bin/${BinaryName}"
      exec $CURDIR/bin/${BinaryName}
